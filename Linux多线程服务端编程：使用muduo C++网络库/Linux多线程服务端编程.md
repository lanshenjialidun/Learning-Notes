> 《Linux多线程服务端编程：使用muduo C++网络库》

####  **第1章 线程安全的对象生命期管理** 
1. 线程安全的类满足三个条件：
-  多个线程同时访问时，其表现正确的行为。
-  无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织
-  调用端代码无需额外的同步或者其他协调操作

2. 对象构造要做到线程安全，唯一的要求是在构造期间不逃泄露this指针，即：
- 不要再构造函数中注册任何回调；
- 不要在构造函数中把this传给跨线程的对象；
- 即使在构造函数的最后一行也不行；

3. 在多线程下，最好使用二段式构造——即构造函数+initialize()。

4. 一个函数如果要锁住相同类型的多个对象，为了保证始终按相同的顺序加锁，我们可以比较mutex对象的地址，始终先加锁地址较小的mutex。  

5. C++里可能出现的内存问题：
 1. 缓冲区溢出（buffer overrun    
 2. 空悬那指针/野指针
 3. 重复释放（double delete）
 4. 内存泄漏（memory leak）
 5. 不配对的new[]/delete
 6. 内存碎片
正确使用智能指针能轻易解决前5个问题。
**记住：资源都是通过对象（智能指针或容器）来管理**
     1. 缓冲区溢出：用std::vector<char>/std::string或自己编写的buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。
     2. 空悬指针/野指针：用share_ptr/weak_ptr。
        3. 重复释放：用scoped_ptr,只在对象析构的时候释放一次。
     4. 内存泄漏：用scoped_ptr,对象析构的时候自动释放内存。
     5. 不配对的new[]/delete：把new[]统统替换为实体店：：vector/scope_arry。  

6. 每一个明确的资源配置动作（例如new）都应该在单一语句中执行，并在该语句中立刻将配置获取的资源交给handle对象（如share_ptr），程序中一般不出现delete。share_ptr是管理共享资源的利器，需要注意避免循环引用，通常做法是owner持有指向child的share_ptr,child持有指向owner的weak_ptr。

提问：计数器类中的锁如果是static，是否影响正确性和性能。 



